// Copyright 2021 Richard Easterling
// SPDX-License-Identifier: Apache-2.0

import 'package:bip32_ed25519/api.dart';
import '../address/shelley_address.dart';
import '../transaction/model/bc_scripts.dart';
import '../transaction/spec/script.dart';
import '../crypto/shelley_key_derivation.dart';
import '../network/network_id.dart';
import 'derivation_chain.dart';

///
/// Shelley address generator for a fixed account index (defualting to zero).
/// Given a extended private key at the account level
/// (i.e. m/1852'/1815'/accountIndex), spend (external), change (internal),
/// staking (reward) and enterprise keys and addresses are generated by
/// appending a role and index segments to the CIP1852 path.
///
/// Cardano CIP1852 adoption of BIP32 path:
///     m / 1852' / 1815' / account' / role / index
///
mixin AbstractAccount {
  ShelleyKeyDerivation get derivation;
  NetworkId get network;
  DerivationChain get chain;
  DerivationChain get chainKey;
}

//mixin AutidAccountMixin {}

/// Read-only Audit Account
class AuditAccount implements AbstractAccount {
  @override
  final DerivationChain chainKey;
  @override
  final ShelleyKeyDerivation derivation;
  @override
  final NetworkId network;
  @override
  final DerivationChain chain;
  final Bip32VerifyKey publicAccountKey;
  late final Bip32VerifyKey publicStakeKey;
  final int accountIndex;

  AuditAccount({
    required this.publicAccountKey,
    //required this.publicStakeKey,
    this.network = NetworkId.mainnet,
    this.accountIndex = 0,
  })  : chain = const DerivationChain(key: 'M', segments: []),
        chainKey = DerivationChain(key: 'M', segments: [
          cip1852,
          cip1815,
          Segment(index: accountIndex, harden: true)
        ]),
        derivation = ShelleyKeyDerivation(publicAccountKey) {
    publicStakeKey = derivation.fromChain(chain.append2(stakeRole, zeroSoft))
        as Bip32VerifyKey;
  }

  Bip32VerifyKey spendPublicKey({int index = 0}) =>
      derivation.fromChain(chain.append2(spendRole, Segment(index: index)))
          as Bip32VerifyKey;

  ShelleyAddress spendAddress({int index = 0}) => ShelleyAddress.toBaseAddress(
      spend: spendPublicKey(index: index),
      stake: publicStakeKey,
      networkId: network);
}

/// Full Wallet Sharing Account
class WalletAccount implements AbstractAccount {
  @override
  final DerivationChain chainKey;
  @override
  final ShelleyKeyDerivation derivation;
  @override
  final NetworkId network;
  final int accountIndex;
  final Bip32SigningKey
      accountSigningKey; //Pvt key at account level m/1852'/1815'/x'
  @override
  final DerivationChain chain;
  WalletAccount({
    required this.accountSigningKey,
    this.network = NetworkId.mainnet,
    this.accountIndex = 0,
  })  : chain = const DerivationChain(key: 'm', segments: [
          cip1852,
          cip1815,
        ]),
        chainKey = const DerivationChain(key: 'm', segments: [
          cip1852,
          cip1815,
        ]),
        derivation = ShelleyKeyDerivation(accountSigningKey);
}

/// Office Account
class Account implements AbstractAccount {
  @override
  final DerivationChain chainKey;
  @override
  final ShelleyKeyDerivation derivation;
  @override
  final NetworkId network;
  final int accountIndex;
  final Bip32SigningKey
      accountSigningKey; //Pvt key at account level m/1852'/1815'/x'
  @override
  final DerivationChain chain;
  late final Bip32VerifyKey publicStakeKey;

  Account({
    required this.accountSigningKey,
    this.network = NetworkId.mainnet,
    this.accountIndex = 0,
  })  : chain = const DerivationChain(key: 'm', segments: []),
        chainKey = DerivationChain(key: 'm', segments: [
          cip1852,
          cip1815,
          Segment(index: accountIndex, harden: true)
        ]),
        derivation = ShelleyKeyDerivation(accountSigningKey) {
    publicStakeKey = derivation
        .fromChain(chain.append2(stakeRole, zeroSoft))
        .publicKey as Bip32VerifyKey;
  }

  Bip32SigningKey basePrivateKey({int index = 0}) =>
      derivation.fromChain(chain.append2(spendRole, Segment(index: index)))
          as Bip32SigningKey;

  Bip32SigningKey changePrivateKey({int index = 0}) =>
      derivation.fromChain(chain.append2(changeRole, Segment(index: index)))
          as Bip32SigningKey;

  Bip32SigningKey stakePrivateKey({int index = 0}) =>
      derivation.fromChain(chain.append2(stakeRole, Segment(index: index)))
          as Bip32SigningKey;

  ShelleyAddress baseAddress({int index = 0}) => ShelleyAddress.toBaseAddress(
      spend: basePrivateKey(index: index).verifyKey,
      stake: publicStakeKey,
      networkId: network);

  ShelleyAddress baseScriptAddress({required BcNativeScript script}) =>
      ShelleyAddress.toBaseScriptAddress(
          script: script, stake: publicStakeKey, networkId: network);

  //header: 0001....
  // public Address getBaseAddress(Script paymentKey, HdPublicKey delegationKey, Network networkInfo) throws CborSerializationException {
  //     if (paymentKey == null || delegationKey == null)
  //         throw new AddressRuntimeException("paymentkey and delegationKey cannot be null");

  //     byte[] paymentKeyHash = paymentKey.getScriptHash();
  //     byte[] delegationKeyHash = delegationKey.getKeyHash();

  //     byte headerType = 0b0001_0000;

  //     return getAddress(paymentKeyHash, delegationKeyHash, headerType, networkInfo, AddressType.Base);
  // }

  ShelleyAddress changeAddress({int index = 0}) => ShelleyAddress.toBaseAddress(
      spend: changePrivateKey(index: index).verifyKey,
      stake: publicStakeKey,
      networkId: network);

  ShelleyAddress enterpriseAddress({int index = 0}) =>
      ShelleyAddress.enterpriseAddress(
          spend: basePrivateKey(index: index).verifyKey, networkId: network);

  ShelleyAddress stakeAddress({int index = 0}) =>
      ShelleyAddress.toRewardAddress(spend: publicStakeKey, networkId: network);
}

// const cip1852 = Segment(index: 1852, harden: true);
// const cip1815 = Segment(index: 1815, harden: true);
// const spendRole = Segment(index: 0); //external
// const changeRole = Segment(index: 1); //internal
// const stakeRole = Segment(index: 2); //reward
// const zeroSoft = Segment(index: 0); //generic zero index not hardened
// const zeroHard = Segment(index: 0, harden: true); //generic zero index hardened

enum HdwUseCase {
  fullWalletSharing,
  audits,
  perOfficeBalances,
  recurrentBToBTx,
  unsecureMoneyReceiver
}
